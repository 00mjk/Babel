#!/usr/bin/python
#
# File:		createarrays.py
# Revision:	@(#) $Revision$
# Date:		$Date$
# Description:	Python to generate arrays for basic types
# Copyright (c) 2000-2001, Lawrence Livermore National Security, LLC
# Produced at the Lawrence Livermore National Laboratory.
# Written by the Components Team <components@llnl.gov>
# UCRL-CODE-2002-054
# All rights reserved.
# 
# This file is part of Babel. For more information, see
# http://www.llnl.gov/CASC/components/. Please read the COPYRIGHT file
# for Our Notice and the LICENSE file for the GNU Lesser General Public
# License.
# 
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License (as published by
# the Free Software Foundation) version 2.1 dated February 1999.
# 
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the IMPLIED WARRANTY OF
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the terms and
# conditions of the GNU Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with this program; if not, write to the Free Software Foundation,
# Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

from sys import stdout
import string

def ReplaceKeywords(text, keywords):
    for key in keywords.keys():
        text = string.replace(text, key, keywords[key])
    return text

dataStructure = """
/**
 * The data structure for multi-dimensional arrays for sidl %ARRAY_TYPE%.
 * The client may access this with the functions below or using
 * the macros in the header file sidlArray.h.
 */
struct %ARRAY_STRUCT% {
  struct sidl__array   d_metadata;
  %ARRAY_FORMAL_TYPE% *d_firstElement;
};

"""

headerTop = """\
/*
 * File:        sidl_%ARRAY_TYPE%_IOR.h
 * Copyright:   (c) 2001-2002 Lawrence Livermore National Security, LLC
 * Revision:    @(#) $Revision$
 * Date:        $Date$
 * Description: %ARRAY_TYPE% array declarations and definitions
 * AUTOMATICALLY GENERATED BY createarrays.py
 *
 */

#ifndef included_sidl_%ARRAY_TYPE%_IOR_h
#define included_sidl_%ARRAY_TYPE%_IOR_h

#ifndef included_sidlType_h
#include "sidlType.h"
#endif

#ifndef included_sidlArray_h
#include "sidlArray.h"
#endif

"""

headerBottom = """\
#ifdef __cplusplus
}
#endif
#endif /* included_sidl_%ARRAY_TYPE%_IOR_h */
"""

implTop = """\
/*
 * File:        sidl_%ARRAY_TYPE%_IOR.c
 * Copyright:   (c) 2001 Lawrence Livermore National Security, LLC
 * Revision:    @(#) $Revision$
 * Date:        $Date$
 * Description: %ARRAY_TYPE% array implementation
 * AUTOMATICALLY GENERATED BY createarrays.py
 *
 * See header file for method comments.
 */

#include "sidl_%ARRAY_TYPE%_IOR.h"
#include <stdlib.h>
#include <string.h>

#ifdef MAX
#undef MAX
#endif
#ifdef MIN
#undef MIN
#endif
#define MAX(x,y) (((x) > (y)) ? (x) : (y))
#define MIN(x,y) (((x) < (y)) ? (x) : (y))

static void swap_i32(int32_t *i1, int32_t *i2)
{
  int32_t tmp = *i1;
  *i1 = *i2;
  *i2 = tmp;
}
"""

implBottom = ""

def WriteComments(out, comment, initMsg):
    lines = string.splitfields(comment, "\n")
    out.write("/**\n")
    for line in lines:
        out.write(" * ")
        out.write(line)
        out.write("\n")
    if (initMsg == 1):
        out.write(" * This function does not initialize the contents of the array.\n")
    if (initMsg >= 2):
        out.write(" * This function initializes the contents of the array to NULL.\n")
    out.write(" */\n")

class Method:
    def __init__(self, comment, signature, impl, initMsg=0, public=1):
        self.signature = signature
        self.comment = comment
        self.impl = impl
        self.public = public
        self.initMsg = initMsg

Methods = [
    
    Method("""\
Destroy the given borrowed array. Trying to destroy a NULL array is
a noop.""",
           """static void
sidl_%ARRAY_TYPE%__array_bdestroy(struct %ARRAY_STRUCT%* array)""",
           """{
  if (array) {
#ifdef SIDL_DEBUG_REFCOUNT
    sidl__array_remove((struct sidl__array *)array);
#endif
    memset(array, 0, sizeof(struct %ARRAY_STRUCT%) +
           3 * (size_t)array->d_metadata.d_dimen * sizeof(int32_t));
    free(array);
  }
}
""", 0, 0),


    Method("""\
Destroy the given array. Trying to destroy a NULL array is a noop.""",
           """static void
sidl_%ARRAY_TYPE%__array_destroy(struct %ARRAY_STRUCT%* array)""",
           """{
  if (array) {
#ifdef DESTROY_VALUES_TOO
    %ARRAY_FORMAL_TYPE% *ptr = array->d_firstElement;
    int32_t i;
    int32_t size = 1;
    HELPER_VARIABLE;
    for(i = 0; i < array->d_metadata.d_dimen;++i){
      size *= (1 + array->d_metadata.d_upper[i] -
                   array->d_metadata.d_lower[i]);
    }
    while (size--) {
      DESTROY_VALUE(*ptr);
      *(ptr++) = NULL;
    }
#endif
    free(array->d_firstElement);
    sidl_%ARRAY_TYPE%__array_bdestroy(array);
  }
}
""", 0, 0),

           
    Method("""\
Destroy the given rarray. Actually doesn't do anything.""",
           """static void
sidl_%ARRAY_TYPE%__array_rdestroy(struct %ARRAY_STRUCT%* array)""",
           """{
#ifdef SIDL_DEBUG_REFCOUNT
  if (array) sidl__array_remove((struct sidl__array *)array);
#endif
}""", 0, 0),
           
    Method("""\
Destroy the given sliced array. Trying to destroy a NULL array is
a noop.""",
           """static void
sidl_%ARRAY_TYPE%__array_sdestroy(struct %ARRAY_STRUCT%* array)""",
           """{
  if (array) {
    static const size_t arraySize = sizeof(struct %ARRAY_STRUCT%)
      + (sizeof(void *) - (sizeof(struct %ARRAY_STRUCT%)
                        % sizeof(void *))) % sizeof(void *);
    struct %ARRAY_STRUCT% **orig;
    orig = (struct %ARRAY_STRUCT% **)((char *)array + arraySize);
    if (*orig) {
      sidl_%ARRAY_TYPE%__array_deleteRef(*orig);
      *orig = NULL;
    }
    sidl_%ARRAY_TYPE%__array_bdestroy(array);
  }
}
""", 0, 0),

    Method("""\
Smart copy routine for self-sufficient and sliced arrays.  This just
increments the reference count and returns the same array.""",
           """static struct %ARRAY_STRUCT%*
sidl_%ARRAY_TYPE%__array_smartCp(struct %ARRAY_STRUCT%* array)""",
           """{
  sidl_%ARRAY_TYPE%__array_addRef(array);
  return array;
}
""", 0, 0),

    Method("""\
Smart copy routine for self-sufficient and sliced arrays.  This just
increments the reference count and returns the same array.""",
           """static struct %ARRAY_STRUCT%*
sidl_%ARRAY_TYPE%__array_borrowSmartCp(struct %ARRAY_STRUCT%* array)""",
           """{
  struct %ARRAY_STRUCT%* copy = NULL;
  if (array) {
    if (sidl_%ARRAY_TYPE%__array_isColumnOrder(array)) {
      copy = sidl_%ARRAY_TYPE%__array_createCol(array->d_metadata.d_dimen,
                                                array->d_metadata.d_lower,
                                                array->d_metadata.d_upper);
    }
    else {
      copy = sidl_%ARRAY_TYPE%__array_createRow(array->d_metadata.d_dimen,
                                                array->d_metadata.d_lower,
                                                array->d_metadata.d_upper);
    }
    sidl_%ARRAY_TYPE%__array_copy(array, copy);
  }
  return copy;
}
""", 0, 0),

    Method("""\
Simple function to return the type of the array.""",
           """static int32_t
%ARRAY_TYPE%_arrayType(void)""",
           """\
{
  return sidl_%ARRAY_TYPE%_array;
}""", 0, 0),

    Method("""\
Virtual function table for rarrays.""",
           "",
           """\
static const struct sidl__array_vtable rarray_%ARRAY_TYPE%_vtable = {
  (void (*)(struct sidl__array *))sidl_%ARRAY_TYPE%__array_rdestroy,
  (struct sidl__array *(*)(struct sidl__array *))
    sidl_%ARRAY_TYPE%__array_borrowSmartCp,
  %ARRAY_TYPE%_arrayType
};""", 0, 0),
           
    Method("""\
Virtual function table for normal, self-sufficient arrays.""",
           "",
           """\
static const struct sidl__array_vtable normal_%ARRAY_TYPE%_vtable = {
  (void (*)(struct sidl__array *))sidl_%ARRAY_TYPE%__array_destroy,
  (struct sidl__array *(*)(struct sidl__array *))
    sidl_%ARRAY_TYPE%__array_smartCp,
  %ARRAY_TYPE%_arrayType
};""", 0, 0),

    Method("""\
Virtual function table for borrowed arrays.""",
           "",
           """\
static const struct sidl__array_vtable borrowed_%ARRAY_TYPE%_vtable = {
  (void (*)(struct sidl__array *))sidl_%ARRAY_TYPE%__array_bdestroy,
  (struct sidl__array *(*)(struct sidl__array *))
    sidl_%ARRAY_TYPE%__array_borrowSmartCp,
  %ARRAY_TYPE%_arrayType
};""", 0, 0),

    Method("""\
Virtual function table for sliced arrays with self-sufficient original
arrays.""",
           "",
           """\
static const struct sidl__array_vtable sliced_%ARRAY_TYPE%_vtable = {
  (void (*)(struct sidl__array *))sidl_%ARRAY_TYPE%__array_sdestroy,
  (struct sidl__array *(*)(struct sidl__array *))
    sidl_%ARRAY_TYPE%__array_smartCp,
  %ARRAY_TYPE%_arrayType
};""", 0, 0),

    Method("""\
Virtual function table for sliced arrays with borrowed original
arrays.""",
           "",
           """\
static const struct sidl__array_vtable bsliced_%ARRAY_TYPE%_vtable = {
  (void (*)(struct sidl__array *))sidl_%ARRAY_TYPE%__array_sdestroy,
  (struct sidl__array *(*)(struct sidl__array *))
    sidl_%ARRAY_TYPE%__array_borrowSmartCp,
  %ARRAY_TYPE%_arrayType
};""", 0, 0),

    Method("""\
Allocate memory for the array meta-data and initialize the reference
count to one.""",
           """static struct %ARRAY_STRUCT%*
newArray(int32_t dimen, const int32_t lower[], const int32_t upper[],
         struct %ARRAY_STRUCT% *orig)""",
           """{
  static const size_t arraySize = sizeof(struct %ARRAY_STRUCT%)
    + (sizeof(void *) - (sizeof(struct %ARRAY_STRUCT%)
                      % sizeof(void *))) % sizeof(void *);
  const size_t baseSize = arraySize +
    (orig ? sizeof(struct %ARRAY_STRUCT% *) : 0);
  const size_t extraBytes = 3 * sizeof(int32_t) * (size_t)dimen;
  const size_t totalSize = baseSize + extraBytes;
  struct %ARRAY_STRUCT% *result = (struct %ARRAY_STRUCT% *)malloc(totalSize);
  result->d_metadata.d_dimen = dimen;
  result->d_metadata.d_refcount = 1;
  result->d_metadata.d_lower = (int32_t *)((char *)result + baseSize);
  result->d_metadata.d_upper = result->d_metadata.d_lower + dimen;
  result->d_metadata.d_stride = result->d_metadata.d_upper + dimen;
  if (orig) {
    struct %ARRAY_STRUCT% **ref;
    ref = (struct %ARRAY_STRUCT% **)((char *)result + arraySize);
    *ref = orig;
    sidl_%ARRAY_TYPE%__array_addRef(orig);
    result->d_metadata.d_vtable = &sliced_%ARRAY_TYPE%_vtable;
  }
  else {
    result->d_metadata.d_vtable = &normal_%ARRAY_TYPE%_vtable;
  }
  memcpy(result->d_metadata.d_lower, lower, sizeof(int32_t)*(size_t)dimen);
  memcpy(result->d_metadata.d_upper, upper, sizeof(int32_t)*(size_t)dimen);
#ifdef SIDL_DEBUG_REFCOUNT
  sidl__array_add((struct sidl__array *)result);
#endif
  return result;
}
""", 0, 0),

    Method("""\
Create a dense %ARRAY_TYPE% array of the given dimension with specified
index bounds in column-major order.  This array owns and manages its data.""",
           """struct %ARRAY_STRUCT% *
sidl_%ARRAY_TYPE%__array_createCol(int32_t       dimen,
     %ARRAY_SPAC%                  const int32_t lower[],
     %ARRAY_SPAC%                  const int32_t upper[])""",
           """{
  int i;
  size_t size=1;
  struct %ARRAY_STRUCT% *result = newArray(dimen, lower, upper, NULL);
  for(i = 0; i < dimen; ++i) {
    result->d_metadata.d_stride[i] = size;
    size *= (size_t)(1 + upper[i] - lower[i]);
  }
  size *= sizeof(%ARRAY_FORMAL_TYPE%);
  result->d_firstElement = (%ARRAY_FORMAL_TYPE% *)malloc(size);
  INIT_VALUES(result->d_firstElement, size);
  return result;
}
""", 255),
    
    Method("""\
Create a dense %ARRAY_TYPE% array of the given dimension with specified
index bounds in row-major order.  This array owns and manages its data.""",
           """struct %ARRAY_STRUCT% *
sidl_%ARRAY_TYPE%__array_createRow(int32_t       dimen,
     %ARRAY_SPAC%                  const int32_t lower[],
     %ARRAY_SPAC%                  const int32_t upper[])""",
           """{
  int i;
  size_t size=1;
  struct %ARRAY_STRUCT% *result = newArray(dimen, lower, upper, NULL);
  for(i = dimen-1; i >= 0; --i) {
    result->d_metadata.d_stride[i] = size;
    size *= (size_t)(1 + upper[i] - lower[i]);
  }
  size *= sizeof(%ARRAY_FORMAL_TYPE%);
  result->d_firstElement = (%ARRAY_FORMAL_TYPE% *)malloc(size);
  INIT_VALUES(result->d_firstElement, size);
  return result;
}
""", 255),


    Method("""\
Initialize the array meta-data for this sidl array from the passed
in pointers. This is a little wierd, but all these pointers must
be allocated, but only upper and c_array actually need to be
initialized.  (We use upper, dim, andc_array to figure out the
correct values for the rest of the data.)""",
           """void
sidl_%ARRAY_TYPE%__array_init(%ARRAY_CONST_TYPE%* c_array,
struct %ARRAY_STRUCT%* sidl_array, int32_t dim,
int32_t lower[], int32_t upper[], int32_t stride[])""",
"""{
  int32_t i = 0;
  int32_t size = 1;
  for(i=0; i < dim; ++i) 
     lower[i] = 0;

  for(i = 0; i < dim; ++i) {
    stride[i] = size;
    size *= (1 + upper[i] - lower[i]);
  }

  sidl_array->d_metadata.d_lower = lower;
  sidl_array->d_metadata.d_upper = upper;
  sidl_array->d_metadata.d_stride = stride;
  sidl_array->d_metadata.d_dimen = dim;	
  sidl_array->d_metadata.d_lower = lower;
  sidl_array->d_metadata.d_vtable = &rarray_%ARRAY_TYPE%_vtable;
  sidl_array->d_metadata.d_refcount = 1;
  sidl_array->d_firstElement = (%ARRAY_FORMAL_TYPE% *)c_array;
#ifdef SIDL_DEBUG_REFCOUNT
  sidl__array_add((struct sidl__array *)sidl_array);
#endif
}
""", 255),


    Method("""\
Create a dense one-dimensional vector of %ARRAY_TYPE%s with a lower
index of 0 and an upper index of len-1. This array owns and manages
its data.""",
           """struct %ARRAY_STRUCT% *
sidl_%ARRAY_TYPE%__array_create1d(int32_t len)""",
           """{
  static const int32_t zero = 0;
  --len;
  return sidl_%ARRAY_TYPE%__array_createCol(1, &zero, &len);
}
""", 255),

    Method("""\
Create a dense one-dimensional vector of %ARRAY_TYPE%s with a lower
index of 0 and an upper index of len-1. The initial data for this
new array is copied from data. For strings, this will make a newly
malloc'ed copy of each non-NULL string. For interfaces/objects, this
will increment the reference count of each non-NULL object/interface
reference.

This array owns and manages its data.""",
           """struct %ARRAY_STRUCT% *
sidl_%ARRAY_TYPE%__array_create1dInit(int32_t len,
     %ARRAY_SPAC%                     %ARRAY_COND_CONST_TYPE%* data)""",
           """{
  struct %ARRAY_STRUCT% *result;
  if (data && (len > 0)) {
    static const int32_t lower = 0;
    const int32_t upper = len - 1;
    result = newArray(1, &lower, &upper, NULL);
    if (result) {
      %ARRAY_COND_CONST_TYPE% * restrict src =
        (%ARRAY_COND_CONST_TYPE% * restrict)data;
      %ARRAY_FORMAL_TYPE% * restrict dest;
      HELPER_VARIABLE;
      result->d_metadata.d_stride[0] = 1;
      result->d_firstElement =
        (%ARRAY_FORMAL_TYPE% *)malloc((size_t)len*sizeof(%ARRAY_FORMAL_TYPE%));
      dest = (%ARRAY_FORMAL_TYPE% * restrict)(result->d_firstElement);
      while (len--) {
        *dest = COPY_VALUE(*src);
        ++dest;
        ++src;
      }
    }
  }
  else {
    result = sidl_%ARRAY_TYPE%__array_create1d(len);
  }
  return result;
}
"""),

   Method("""\
Create a dense two-dimensional array of %ARRAY_TYPE%s with a lower
indices of (0,0) and an upper indices of (m-1,n-1). The array is
stored in column-major order, and it owns and manages its data.""",
          """struct %ARRAY_STRUCT% *
sidl_%ARRAY_TYPE%__array_create2dCol(int32_t m, int32_t n)""",
           """{
  static const int32_t zero[2] = {0, 0};
  int32_t upper[2];
  upper[0] = m-1;
  upper[1] = n-1;
  return sidl_%ARRAY_TYPE%__array_createCol(2, zero, upper);
}
""", 255),

   Method("""\
Create a dense two-dimensional array of %ARRAY_TYPE%s with a lower
indices of (0,0) and an upper indices of (m-1,n-1). The array is
stored in row-major order, and it owns and manages its data.""",
          """struct %ARRAY_STRUCT% *
sidl_%ARRAY_TYPE%__array_create2dRow(int32_t m, int32_t n)""",
           """{
  static const int32_t zero[2] = {0, 0};
  int32_t upper[2];
  upper[0] = m-1;
  upper[1] = n-1;
  return sidl_%ARRAY_TYPE%__array_createRow(2, zero, upper);
}
""", 255),

    Method("""\
Return the stride for a splice argument.""",
           """static int32_t
getStride(const int32_t *srcStride, const int32_t i)""",
           """{
  return srcStride ? srcStride[i] : 1;
}""", 0, 0),
    
    Method("""\
Check the arguments of a splice call to make sure they're valid.""",
           """static int
goodSliceArgs(struct %ARRAY_STRUCT%* src,
               int32_t       dimen,
               const int32_t *srcStart,
               const int32_t *srcStride,
               const int32_t *newStart,
               const int32_t *numElem)""",
           """{
  if (src && numElem && (dimen > 0) && (dimen <= src->d_metadata.d_dimen)) {
    int32_t i, numZeros;
    const int32_t *srcFirst = (srcStart ? srcStart : src->d_metadata.d_lower);
    for(i = 0, numZeros=0; i < src->d_metadata.d_dimen; ++i) {
      if ((srcFirst[i] < src->d_metadata.d_lower[i]) ||
          (srcFirst[i] > src->d_metadata.d_upper[i]) ||
          (numElem[i] &&
           (((srcFirst[i] + (numElem[i]-1)*getStride(srcStride,i)) >
              src->d_metadata.d_upper[i]) ||
            ((srcFirst[i] + (numElem[i]-1)*getStride(srcStride,i)) <
              src->d_metadata.d_lower[i]))))
        return 0;
      if (!numElem[i]) ++numZeros;
    }
    return (dimen + numZeros) == src->d_metadata.d_dimen;
  }
  return 0;
}
""", 0, 0),

    Method("""\
Create a sub-array of another array. This resulting array shares
data with the original array. The new array can be of the same
dimension or potentially less assuming the original array has
dimension greater than 1.  If you are removing dimension, indicate the
dimensions to remove by setting numElem[i] to zero for any dimension i
that should go away in the new array.  The meaning of each argument
is covered below.

src       the array to be created will be a subset of this array. If
          this argument is NULL, NULL will be returned. The array
          returned borrows data from src, so modifying src or the
          returned array will modify both arrays.

dimen     this argument must be greater than zero and less than or
          equal to the dimension of src. An illegal value will cause
          a NULL return value.
          
numElem   this specifies how many elements from src should be taken in
          each dimension. A zero entry indicates that the dimension
          should not appear in the new array.  This argument should be
          an array with an entry for each dimension of src.  Passing
          NULL here will cause NULL to be returned.  If
          srcStart[i] + numElem[i]*srcStride[i] is greater than
          upper[i] for src or if srcStart[i] + numElem[i]*srcStride[i]
          is less than lower[i] for src, NULL will be returned.

srcStart  this array holds the coordinates of the first element of the
          new array. If this argument is NULL, the first element of
          src will be the first element of the new array. If non-NULL,
          this argument should be an array with an entry for each
          dimension of src.  If srcStart[i] is less than lower[i] for
          the array src, NULL will be returned.

srcStride this array lets you specify the stride between elements in
          each dimension of src. This stride is relative to the
          coordinate system of the src array. If this argument is
          NULL, the stride is taken to be one in each dimension.
          If non-NULL, this argument should be an array with an entry
          for each dimension of src.

newLower  this argument is like lower in a create method. It sets the
          coordinates for the first element in the new array.  If this
          argument is NULL, the values indicated by srcStart will be
          used. If non-NULL, this should be an array with dimen
          elements.""",
           """struct %ARRAY_STRUCT% *
sidl_%ARRAY_TYPE%__array_slice(struct %ARRAY_STRUCT% *src,
     %ARRAY_SPAC%              int32_t       dimen,
     %ARRAY_SPAC%              const int32_t numElem[],
     %ARRAY_SPAC%              const int32_t *srcStart,
     %ARRAY_SPAC%              const int32_t *srcStride,
     %ARRAY_SPAC%              const int32_t *newStart)""",
           """{
  struct %ARRAY_STRUCT% *result = NULL;
  if (goodSliceArgs(src, dimen, srcStart, srcStride, newStart, numElem)) {
    const int32_t *srcFirst = (srcStart ? srcStart : src->d_metadata.d_lower);
    const int32_t *newFirst = (newStart ? newStart : srcFirst);
    int32_t *newLast = malloc(sizeof(int32_t)*(size_t)dimen);
    int32_t i, j;
    if (!newLast) return NULL;
    for(i = 0, j = 0; i < src->d_metadata.d_dimen; ++i) {
      if (numElem[i]) {
        newLast[j] = newFirst[j] + numElem[i] - 1;
        ++j;
      }
    }
    result = newArray(dimen, newFirst, newLast, src);
    free(newLast);
    if (result) {
      result->d_firstElement = src->d_firstElement;
      for(i = 0, j = 0; i < src->d_metadata.d_dimen; ++i) {
        result->d_firstElement +=
          ((srcFirst[i] - src->d_metadata.d_lower[i])*
           src->d_metadata.d_stride[i]);
        if (numElem[i]) {
          result->d_metadata.d_stride[j] = src->d_metadata.d_stride[i]*
            getStride(srcStride, i);
          ++j;
        }
      }
      if (src->d_metadata.d_vtable->d_smartcopy ==
          (struct sidl__array *(*)(struct sidl__array *))
           sidl_%ARRAY_TYPE%__array_smartCp) {
        result->d_metadata.d_vtable = &sliced_%ARRAY_TYPE%_vtable;
      }
      else {
        result->d_metadata.d_vtable = &bsliced_%ARRAY_TYPE%_vtable;
      }
    }
  }
  return result;
}
"""),

    Method("""\
Create an array that uses data memory from another source. This initial
contents are determined by the data being borrowed.""",
           """struct %ARRAY_STRUCT% *
sidl_%ARRAY_TYPE%__array_borrow(%ARRAY_FORMAL_TYPE%* firstElement,
     %ARRAY_SPAC%               int32_t        dimen,
     %ARRAY_SPAC%               const int32_t  lower[],
     %ARRAY_SPAC%               const int32_t  upper[],
     %ARRAY_SPAC%               const int32_t  stride[])""",
           """{
  struct %ARRAY_STRUCT% *result = newArray(dimen, lower, upper, NULL);
  memcpy(result->d_metadata.d_stride, stride, sizeof(int32_t)*(size_t)dimen);
  result->d_firstElement = firstElement;
  result->d_metadata.d_vtable = &borrowed_%ARRAY_TYPE%_vtable;
  return result;
}
"""),

    Method("""\
If array is borrowed, allocate a new self-sufficient array and copy
the borrowed array into the new array; otherwise, increment the
reference count and return the array passed in. Use this whenever
you want to make a copy of a method argument because arrays passed
into methods aren't guaranteed to exist after the method call.""",
           """struct %ARRAY_STRUCT% *
sidl_%ARRAY_TYPE%__array_smartCopy(struct %ARRAY_STRUCT% *array)""",
           """{
  return (struct %ARRAY_STRUCT% *)
     sidl__array_smartCopy((struct sidl__array*)array);
}
"""),

    Method("""\
Increment the arrays internal reference count by one. To make a
persistent copy (i.e. that lives longer than the current method
call) use smartCopy.""",
           """void
sidl_%ARRAY_TYPE%__array_addRef(struct %ARRAY_STRUCT%* array)""",
           """{
  sidl__array_addRef((struct sidl__array*)array);
}
"""),

    Method("""\
Decrement the arrays internal reference count by one. If the reference
count goes to zero, destroy the array.
Return true iff the array is destroyed""",
           """void
sidl_%ARRAY_TYPE%__array_deleteRef(struct %ARRAY_STRUCT%* array)""",
           """{
  sidl__array_deleteRef((struct sidl__array*)array);
}
"""),

    Method("""\
Attempt to cast a generic array reference to an %ARRAY_TYPE%
array. A non-NULL return value indicates that the cast was
successful, and the returned pointer is a valid %ARRAY_TYPE%
array. A NULL return value indicates that the cast failed.
This function never alters the reference count of array.
""",
           """struct %ARRAY_STRUCT%*
sidl_%ARRAY_TYPE%__array_cast(struct sidl__array* array)""",
           """{
  return (array &&
          (sidl_%ARRAY_TYPE%_array == ((array->d_vtable->d_arraytype)())))
    ? (struct %ARRAY_STRUCT% *)array : NULL;
}
"""),

    Method("""\
Retrieve element i1 of a one-dimensional array.""",
           """%ARRAY_FORMAL_TYPE%
sidl_%ARRAY_TYPE%__array_get1(const struct %ARRAY_STRUCT%* array,
     %ARRAY_SPAC%             const int32_t i1)""",
           """{
  if (array && (1 == array->d_metadata.d_dimen) &&
      ((array->d_metadata.d_lower[0] <= i1) &&
      (array->d_metadata.d_upper[0] >= i1))) {
    HELPER_VARIABLE;
    return COPY_VALUE(*(array->d_firstElement +
                        (i1 - array->d_metadata.d_lower[0])*
                        array->d_metadata.d_stride[0]));
  }
  return sidl_%ARRAY_TYPE%__array_zero;
}
"""),

    Method("""\
Retrieve element (i1,i2) of a two-dimensional array.""",
           """%ARRAY_FORMAL_TYPE%
sidl_%ARRAY_TYPE%__array_get2(const struct %ARRAY_STRUCT%* array,
     %ARRAY_SPAC%             const int32_t i1,
     %ARRAY_SPAC%             const int32_t i2)""",
           """{
  if (array && (2 == array->d_metadata.d_dimen)){
    const int32_t * const low = array->d_metadata.d_lower;
    const int32_t * const up = array->d_metadata.d_upper;
    const int32_t * const stride = array->d_metadata.d_stride;
    /* unserialize array bounds checking (i.e. avoid strict left to right */
    /* evaluation of && which serializes evaluation) */
    register int c1 = (low[0] <= i1);
    register int c2 = (up[0] >= i1);
    register int c3 = (low[1] <= i2);
    register int c4 = (up[1] >= i2);
    HELPER_VARIABLE;
    c1 = c1 && c2;
    c3 = c3 && c4;
    if (c1 && c3) {
      return COPY_VALUE(*(array->d_firstElement +
                          (i1 - low[0])* stride[0] +
                          (i2 - low[1])* stride[1]));
    }
  }
  return sidl_%ARRAY_TYPE%__array_zero;
}
"""),

    Method("""\
Retrieve element (i1,i2,i3) of a three-dimensional array.""",
           """%ARRAY_FORMAL_TYPE%
sidl_%ARRAY_TYPE%__array_get3(const struct %ARRAY_STRUCT%* array,
     %ARRAY_SPAC%             const int32_t i1,
     %ARRAY_SPAC%             const int32_t i2,
     %ARRAY_SPAC%             const int32_t i3)""",
           """{
  if (array && (3 == array->d_metadata.d_dimen)){
    const int32_t * const low = array->d_metadata.d_lower;
    const int32_t * const up = array->d_metadata.d_upper;
    const int32_t * const stride = array->d_metadata.d_stride;
    /* unserialize array bounds checking (i.e. avoid strict left to right */
    /* evaluation of && which serializes evaluation) */
    register int c1 = (low[0] <= i1);
    register int c2 = (low[1] <= i2);
    register int c3 = (low[2] <= i3);
    HELPER_VARIABLE;
    c1 = c1 && (up[0] >= i1);
    c2 = c2 && (up[1] >= i2);
    c3 = c3 && (up[2] >= i3);
    if (c1 && c2 && c3) {
      return COPY_VALUE(*(array->d_firstElement +
                          (i1 - low[0])* stride[0] +
                          (i2 - low[1])* stride[1] +
                          (i3 - low[2])* stride[2]));
    }
  }
  return sidl_%ARRAY_TYPE%__array_zero;
}
"""),


    Method("""\
Retrieve element (i1,i2,i3,i4) of a four-dimensional array.""",
           """%ARRAY_FORMAL_TYPE%
sidl_%ARRAY_TYPE%__array_get4(const struct %ARRAY_STRUCT%* array,
     %ARRAY_SPAC%             const int32_t i1,
     %ARRAY_SPAC%             const int32_t i2,
     %ARRAY_SPAC%             const int32_t i3,
     %ARRAY_SPAC%             const int32_t i4)""",
           """{
  if (array && (4 == array->d_metadata.d_dimen)){
    const int32_t * const low = array->d_metadata.d_lower;
    const int32_t * const up = array->d_metadata.d_upper;
    const int32_t * const stride = array->d_metadata.d_stride;
    /* unserialize array bounds checking to avoid strict left to right */
    /* evaluation of && which serializes evaluation */
    register int c1 = (low[0] <= i1);
    register int c2 = (low[1] <= i2);
    register int c3 = (low[2] <= i3);
    register int c4 = (low[3] <= i4);
    HELPER_VARIABLE;
    c1 = c1 && (up[0] >= i1);
    c2 = c2 && (up[1] >= i2);
    c3 = c3 && (up[2] >= i3);
    c4 = c4 && (up[3] >= i4);
    c1 = c1 && c2;
    c3 = c3 && c4;
    if (c1 && c3) {
      return COPY_VALUE(*(array->d_firstElement +
                         (((i1 - low[0])* stride[0] +
                           (i2 - low[1])* stride[1]) +
                          ((i3 - low[2])* stride[2] +
                           (i4 - low[3])* stride[3]))));
    }
  }
  return sidl_%ARRAY_TYPE%__array_zero;
}
"""),

    Method("""\
Retrieve element (i1,i2,i3,i4,i5) of a five-dimensional array.""",
           """%ARRAY_FORMAL_TYPE%
sidl_%ARRAY_TYPE%__array_get5(const struct %ARRAY_STRUCT%* array,
     %ARRAY_SPAC%             const int32_t i1,
     %ARRAY_SPAC%             const int32_t i2,
     %ARRAY_SPAC%             const int32_t i3,
     %ARRAY_SPAC%             const int32_t i4,
     %ARRAY_SPAC%             const int32_t i5)""",
           """{
  if (array && (5 == array->d_metadata.d_dimen)){
    const int32_t * const low = array->d_metadata.d_lower;
    const int32_t * const up = array->d_metadata.d_upper;
    const int32_t * const stride = array->d_metadata.d_stride;
    /* unserialize array bounds checking (i.e. avoid strict left to right */
    /* evaluation of && which serializes evaluation) */
    register int c1 = (low[0] <= i1);
    register int c2 = (low[1] <= i2);
    register int c3 = (low[2] <= i3);
    register int c4 = (low[3] <= i4);
    register int c5 = (low[4] <= i5);
    HELPER_VARIABLE;
    c1 = c1 && (up[0] >= i1);
    c2 = c2 && (up[1] >= i2);
    c3 = c3 && (up[2] >= i3);
    c4 = c4 && (up[3] >= i4);
    c5 = c5 && (up[4] >= i5);
    c1 = c1 && c2;
    c3 = c3 && c4;
    c1 = c1 && c3;
    if (c1 && c5) {
      return COPY_VALUE(*(array->d_firstElement +
                          (i1 - low[0])* stride[0] +
                          (i2 - low[1])* stride[1] +
                          (i3 - low[2])* stride[2] +
                          (i4 - low[3])* stride[3] +
                          (i5 - low[4])* stride[4]));
    }
  }
  return sidl_%ARRAY_TYPE%__array_zero;
}
"""),


    Method("""\
Retrieve element (i1,i2,i3,i4,i5,i6) of a six-dimensional array.""",
           """%ARRAY_FORMAL_TYPE%
sidl_%ARRAY_TYPE%__array_get6(const struct %ARRAY_STRUCT%* array,
     %ARRAY_SPAC%             const int32_t i1,
     %ARRAY_SPAC%             const int32_t i2,
     %ARRAY_SPAC%             const int32_t i3,
     %ARRAY_SPAC%             const int32_t i4,
     %ARRAY_SPAC%             const int32_t i5,
     %ARRAY_SPAC%             const int32_t i6)""",
           """{
  if (array && (6 == array->d_metadata.d_dimen)){
    const int32_t * const low = array->d_metadata.d_lower;
    const int32_t * const up = array->d_metadata.d_upper;
    const int32_t * const stride = array->d_metadata.d_stride;
    /* unserialize array bounds checking (i.e. avoid strict left to right */
    /* evaluation of && which serializes evaluation) */
    register int c1 = (low[0] <= i1);
    register int c2 = (low[1] <= i2);
    register int c3 = (low[2] <= i3);
    register int c4 = (low[3] <= i4);
    register int c5 = (low[4] <= i5);
    register int c6 = (low[5] <= i6);
    HELPER_VARIABLE;
    c1 = c1 && (up[0] >= i1);
    c2 = c2 && (up[1] >= i2);
    c3 = c3 && (up[2] >= i3);
    c4 = c4 && (up[3] >= i4);
    c5 = c5 && (up[4] >= i5);
    c6 = c6 && (up[5] >= i6);
    c1 = c1 && c2;
    c3 = c3 && c4;
    c5 = c5 && c6;
    c1 = c1 && c3;
    if (c1 && c5) {
      return COPY_VALUE(*(array->d_firstElement +
                          (i1 - low[0])* stride[0] +
                          (i2 - low[1])* stride[1] +
                          (i3 - low[2])* stride[2] +
                          (i4 - low[3])* stride[3] +
                          (i5 - low[4])* stride[4] +
                          (i6 - low[5])* stride[5]));
    }
  }
  return sidl_%ARRAY_TYPE%__array_zero;
}
"""),


    Method("""\
Retrieve element (i1,i2,i3,i4,i5,i6,i7) of a seven-dimensional array.""",
           """%ARRAY_FORMAL_TYPE%
sidl_%ARRAY_TYPE%__array_get7(const struct %ARRAY_STRUCT%* array,
     %ARRAY_SPAC%             const int32_t i1,
     %ARRAY_SPAC%             const int32_t i2,
     %ARRAY_SPAC%             const int32_t i3,
     %ARRAY_SPAC%             const int32_t i4,
     %ARRAY_SPAC%             const int32_t i5,
     %ARRAY_SPAC%             const int32_t i6,
     %ARRAY_SPAC%             const int32_t i7)""",
           """{
  if (array) {
    switch(array->d_metadata.d_dimen) {
    case 1: return sidl_%ARRAY_TYPE%__array_get1(array, i1);
    case 2: return sidl_%ARRAY_TYPE%__array_get2(array, i1, i2);
    case 3: return sidl_%ARRAY_TYPE%__array_get3(array, i1, i2, i3);
    case 4: return sidl_%ARRAY_TYPE%__array_get4(array, i1, i2, i3, i4);
    case 5: return sidl_%ARRAY_TYPE%__array_get5(array, i1, i2, i3, i4, i5);
    case 6: return sidl_%ARRAY_TYPE%__array_get6(array, i1, i2, i3, i4, i5, i6);
    case 7:
      {
        const int32_t * const low = array->d_metadata.d_lower;
        const int32_t * const up = array->d_metadata.d_upper;
        const int32_t * const stride = array->d_metadata.d_stride;
        /* unserialize array bounds checking (i.e. avoid strict left to right */
        /* evaluation of && which serializes evaluation) */
        register int c1 = (low[0] <= i1);
        register int c2 = (low[1] <= i2);
        register int c3 = (low[2] <= i3);
        register int c4 = (low[3] <= i4);
        register int c5 = (low[4] <= i5);
        register int c6 = (low[5] <= i6);
        register int c7 = (low[6] <= i7);
        HELPER_VARIABLE;
        c1 = c1 && (up[0] >= i1);
        c2 = c2 && (up[1] >= i2);
        c3 = c3 && (up[2] >= i3);
        c4 = c4 && (up[3] >= i4);
        c5 = c5 && (up[4] >= i5);
        c6 = c6 && (up[5] >= i6);
        c7 = c7 && (up[6] >= i7);
        c1 = c1 && c2;
        c3 = c3 && c4;
        c5 = c5 && c6;
        c1 = c1 && c3;
        c5 = c5 && c7;
        if (c1 && c5) {
          return COPY_VALUE(*(array->d_firstElement +
                              (i1 - low[0])* stride[0] +
                              (i2 - low[1])* stride[1] +
                              (i3 - low[2])* stride[2] +
                              (i4 - low[3])* stride[3] +
                              (i5 - low[4])* stride[4] +
                              (i6 - low[5])* stride[5] +
                              (i7 - low[6])* stride[6]));
        }
      }
    }
  }
  return sidl_%ARRAY_TYPE%__array_zero;
}
"""),


    Method("""\
Retrieve element indices of an n-dimensional array. Indices is assumed
to have the right number of elements for the dimension of array.""",
           """%ARRAY_FORMAL_TYPE%
sidl_%ARRAY_TYPE%__array_get(const struct %ARRAY_STRUCT%* array,
     %ARRAY_SPAC%            const int32_t indices[])""",
           """{
  if (array) {
    %ARRAY_FORMAL_TYPE% *result = array->d_firstElement;
    int32_t i = 0;
    HELPER_VARIABLE;
    while (i < array->d_metadata.d_dimen) {
      if ((indices[i] < array->d_metadata.d_lower[i]) ||
          (indices[i] > array->d_metadata.d_upper[i]))
        return sidl_%ARRAY_TYPE%__array_zero;
      result += ((indices[i] - array->d_metadata.d_lower[i])*
       array->d_metadata.d_stride[i]);
      ++i;
    }
    return COPY_VALUE(*result);
  }
  return sidl_%ARRAY_TYPE%__array_zero;
}
"""),

    Method("""\
Set element i1 of a one-dimensional array to value.""",
           """void
sidl_%ARRAY_TYPE%__array_set1(struct %ARRAY_STRUCT%* array,
     %ARRAY_SPAC%             const int32_t i1,
     %ARRAY_SPAC%             %ARRAY_CONST_TYPE% value)""",
           """{
  if (array && (1 == array->d_metadata.d_dimen) &&
      ((array->d_metadata.d_lower[0] <= i1) &&
       (array->d_metadata.d_upper[0] >= i1))) {
    HELPER_VARIABLE;
    DESTROY_VALUE(*(array->d_firstElement +
      (i1 - array->d_metadata.d_lower[0])*array->d_metadata.d_stride[0]));
    *(array->d_firstElement +
      (i1 - array->d_metadata.d_lower[0])*array->d_metadata.d_stride[0]) =
       COPY_VALUE(value);
  }
}
"""),

    Method("""\
Set element (i1,i2) of a two-dimensional array to value.""",
           """void
sidl_%ARRAY_TYPE%__array_set2(struct %ARRAY_STRUCT%* array,
     %ARRAY_SPAC%             const int32_t i1,
     %ARRAY_SPAC%             const int32_t i2,
     %ARRAY_SPAC%             %ARRAY_CONST_TYPE% value)""",
           """{
  if (array && (2 == array->d_metadata.d_dimen)){
    const int32_t * const low = array->d_metadata.d_lower;
    const int32_t * const up = array->d_metadata.d_upper;
    const int32_t * const stride = array->d_metadata.d_stride;
    /* unserialize array bounds checking (i.e. avoid strict left to right */
    /* evaluation of && which serializes evaluation) */
    register int c1 = (low[0] <= i1);
    register int c2 = (up[0] >= i1);
    register int c3 = (low[1] <= i2);
    register int c4 = (up[1] >= i2);
    HELPER_VARIABLE;
    c1 = c1 && c2;
    c3 = c3 && c4;
    if (c1 && c3) {
      DESTROY_VALUE(*(array->d_firstElement +
        (i1 - low[0])*stride[0] +
        (i2 - low[1])*stride[1]));
      *(array->d_firstElement +
        (i1 - low[0])*stride[0] +
        (i2 - low[1])*stride[1]) =
         COPY_VALUE(value);
    }
  }
}
"""),

    Method("""\
Set element (i1,i2,i3) of a three-dimensional array to value.""",
           """void
sidl_%ARRAY_TYPE%__array_set3(struct %ARRAY_STRUCT%* array,
     %ARRAY_SPAC%             const int32_t i1,
     %ARRAY_SPAC%             const int32_t i2,
     %ARRAY_SPAC%             const int32_t i3,
     %ARRAY_SPAC%             %ARRAY_CONST_TYPE% value)""",
           """{
  if (array && (3 == array->d_metadata.d_dimen)){
    const int32_t * const low = array->d_metadata.d_lower;
    const int32_t * const up = array->d_metadata.d_upper;
    const int32_t * const stride = array->d_metadata.d_stride;
    /* unserialize array bounds checking (i.e. avoid strict left to right */
    /* evaluation of && which serializes evaluation) */
    register int c1 = (low[0] <= i1);
    register int c2 = (low[1] <= i2);
    register int c3 = (low[2] <= i3);
    HELPER_VARIABLE;
    c1 = c1 && (up[0] >= i1);
    c2 = c2 && (up[1] >= i2);
    c3 = c3 && (up[2] >= i3);
    if (c1 && c2 && c3) {
      DESTROY_VALUE(*(array->d_firstElement +
        (i1 - low[0])*stride[0] +
        (i2 - low[1])*stride[1] +
        (i3 - low[2])*stride[2]));
      *(array->d_firstElement +
        (i1 - low[0])*stride[0] +
        (i2 - low[1])*stride[1] +
        (i3 - low[2])*stride[2]) =
         COPY_VALUE(value);
    }
  }
}
"""),


    Method("""\
Set element (i1,i2,i3,i4) of a four-dimensional array to value.""",
           """void
sidl_%ARRAY_TYPE%__array_set4(struct %ARRAY_STRUCT%* array,
     %ARRAY_SPAC%             const int32_t i1,
     %ARRAY_SPAC%             const int32_t i2,
     %ARRAY_SPAC%             const int32_t i3,
     %ARRAY_SPAC%             const int32_t i4,
     %ARRAY_SPAC%             %ARRAY_CONST_TYPE% value)""",
           """{
  if (array && (array->d_metadata.d_dimen == 4)) {
    const int32_t * const low = array->d_metadata.d_lower;
    const int32_t * const up = array->d_metadata.d_upper;
    const int32_t * const stride = array->d_metadata.d_stride;
    /* unserialize array bounds checking to. avoid strict left to right */
    /* evaluation of && which serializes evaluation */
    register int c1 = (low[0] <= i1);
    register int c2 = (low[1] <= i2);
    register int c3 = (low[2] <= i3);
    register int c4 = (low[3] <= i4);
    HELPER_VARIABLE;
    c1 = c1 && (up[0] >= i1);
    c2 = c2 && (up[1] >= i2);
    c3 = c3 && (up[2] >= i3);
    c4 = c4 && (up[3] >= i4);
    c1 = c1 && c2;
    c3 = c3 && c4;
    if (c1 && c3) {
      DESTROY_VALUE(*(array->d_firstElement +
        (((i1 - low[0])*stride[0] +
          (i2 - low[1])*stride[1]) +
         ((i3 - low[2])*stride[2] +
          (i4 - low[3])*
           stride[3]))));
      *(array->d_firstElement +
        (((i1 - low[0])*stride[0] +
          (i2 - low[1])*stride[1]) +
         ((i3 - low[2])*stride[2] +
         (i4 - low[3])*stride[3]))) =
         COPY_VALUE(value);
    }
  }
}
"""),

    Method("""\
Set element (i1,i2,i3,i4,i5) of a five-dimensional array to value.""",
           """void
sidl_%ARRAY_TYPE%__array_set5(struct %ARRAY_STRUCT%* array,
     %ARRAY_SPAC%             const int32_t i1,
     %ARRAY_SPAC%             const int32_t i2,
     %ARRAY_SPAC%             const int32_t i3,
     %ARRAY_SPAC%             const int32_t i4,
     %ARRAY_SPAC%             const int32_t i5,
     %ARRAY_SPAC%             %ARRAY_CONST_TYPE% value)""",
           """{
  if (array && (5 == array->d_metadata.d_dimen)){
    const int32_t * const low = array->d_metadata.d_lower;
    const int32_t * const up = array->d_metadata.d_upper;
    const int32_t * const stride = array->d_metadata.d_stride;
    /* unserialize array bounds checking (i.e. avoid strict left to right */
    /* evaluation of && which serializes evaluation) */
    register int c1 = (low[0] <= i1);
    register int c2 = (low[1] <= i2);
    register int c3 = (low[2] <= i3);
    register int c4 = (low[3] <= i4);
    register int c5 = (low[4] <= i5);
    HELPER_VARIABLE;
    c1 = c1 && (up[0] >= i1);
    c2 = c2 && (up[1] >= i2);
    c3 = c3 && (up[2] >= i3);
    c4 = c4 && (up[3] >= i4);
    c5 = c5 && (up[4] >= i5);
    c1 = c1 && c2;
    c3 = c3 && c4;
    c1 = c1 && c3;
    if (c1 && c5) {
      DESTROY_VALUE(*(array->d_firstElement +
        (i1 - low[0])*stride[0] +
        (i2 - low[1])*stride[1] +
        (i3 - low[2])*stride[2] +
        (i4 - low[3])*stride[3] +
        (i5 - low[4])*stride[4]));
      *(array->d_firstElement +
        (i1 - low[0])*stride[0] +
        (i2 - low[1])*stride[1] +
        (i3 - low[2])*stride[2] +
        (i4 - low[3])*stride[3] +
        (i5 - low[4])*stride[4]) =
         COPY_VALUE(value);
    }
  }
}
"""),


    Method("""\
Set element (i1,i2,i3,i4,i5,i6) of a six-dimensional array to value.""",
           """void
sidl_%ARRAY_TYPE%__array_set6(struct %ARRAY_STRUCT%* array,
     %ARRAY_SPAC%             const int32_t i1,
     %ARRAY_SPAC%             const int32_t i2,
     %ARRAY_SPAC%             const int32_t i3,
     %ARRAY_SPAC%             const int32_t i4,
     %ARRAY_SPAC%             const int32_t i5,
     %ARRAY_SPAC%             const int32_t i6,
     %ARRAY_SPAC%             %ARRAY_CONST_TYPE% value)""",
           """{
  if (array && (6 == array->d_metadata.d_dimen)){
    const int32_t * const low = array->d_metadata.d_lower;
    const int32_t * const up = array->d_metadata.d_upper;
    const int32_t * const stride = array->d_metadata.d_stride;
    /* unserialize array bounds checking (i.e. avoid strict left to right */
    /* evaluation of && which serializes evaluation) */
    register int c1 = (low[0] <= i1);
    register int c2 = (low[1] <= i2);
    register int c3 = (low[2] <= i3);
    register int c4 = (low[3] <= i4);
    register int c5 = (low[4] <= i5);
    register int c6 = (low[5] <= i6);
    HELPER_VARIABLE;
    c1 = c1 && (up[0] >= i1);
    c2 = c2 && (up[1] >= i2);
    c3 = c3 && (up[2] >= i3);
    c4 = c4 && (up[3] >= i4);
    c5 = c5 && (up[4] >= i5);
    c6 = c6 && (up[5] >= i6);
    c1 = c1 && c2;
    c3 = c3 && c4;
    c5 = c5 && c6;
    c1 = c1 && c3;
    if (c1 && c5) {
      DESTROY_VALUE(*(array->d_firstElement +
        (i1 - low[0])*stride[0] +
        (i2 - low[1])*stride[1] +
        (i3 - low[2])*stride[2] +
        (i4 - low[3])*stride[3] +
        (i5 - low[4])*stride[4] +
        (i6 - low[5])*stride[5]));
      *(array->d_firstElement +
        (i1 - low[0])*stride[0] +
        (i2 - low[1])*stride[1] +
        (i3 - low[2])*stride[2] +
        (i4 - low[3])*stride[3] +
        (i5 - low[4])*stride[4] +
        (i6 - low[5])*stride[5]) =
         COPY_VALUE(value);
    }
  }
}
"""),


    Method("""\
Set element (i1,i2,i3,i4,i5,i6,i7) of a seven-dimensional array to value.""",
           """void
sidl_%ARRAY_TYPE%__array_set7(struct %ARRAY_STRUCT%* array,
     %ARRAY_SPAC%             const int32_t i1,
     %ARRAY_SPAC%             const int32_t i2,
     %ARRAY_SPAC%             const int32_t i3,
     %ARRAY_SPAC%             const int32_t i4,
     %ARRAY_SPAC%             const int32_t i5,
     %ARRAY_SPAC%             const int32_t i6,
     %ARRAY_SPAC%             const int32_t i7,
     %ARRAY_SPAC%             %ARRAY_CONST_TYPE% value)""",
           """{
  if (array) {
    switch(array->d_metadata.d_dimen) {
    case 1: sidl_%ARRAY_TYPE%__array_set1(array, i1, value); break;
    case 2: sidl_%ARRAY_TYPE%__array_set2(array, i1, i2, value); break;
    case 3: sidl_%ARRAY_TYPE%__array_set3(array, i1, i2, i3, value); break;
    case 4: sidl_%ARRAY_TYPE%__array_set4(array, i1, i2, i3, i4, value); break;
    case 5: sidl_%ARRAY_TYPE%__array_set5(array, i1, i2, i3, i4, i5, value); break;
    case 6: sidl_%ARRAY_TYPE%__array_set6(array, i1, i2, i3, i4, i5, i6, value); break;
    case 7:
      {
        const int32_t * const low = array->d_metadata.d_lower;
        const int32_t * const up = array->d_metadata.d_upper;
        const int32_t * const stride = array->d_metadata.d_stride;
        /* unserialize array bounds checking (i.e. avoid strict left to right */
        /* evaluation of && which serializes evaluation) */
        register int c1 = (low[0] <= i1);
        register int c2 = (low[1] <= i2);
        register int c3 = (low[2] <= i3);
        register int c4 = (low[3] <= i4);
        register int c5 = (low[4] <= i5);
        register int c6 = (low[5] <= i6);
        register int c7 = (low[6] <= i7);
        HELPER_VARIABLE;
        c1 = c1 && (up[0] >= i1);
        c2 = c2 && (up[1] >= i2);
        c3 = c3 && (up[2] >= i3);
        c4 = c4 && (up[3] >= i4);
        c5 = c5 && (up[4] >= i5);
        c6 = c6 && (up[5] >= i6);
        c7 = c7 && (up[6] >= i7);
        c1 = c1 && c2;
        c3 = c3 && c4;
        c5 = c5 && c6;
        c1 = c1 && c3;
        c5 = c5 && c7;
        if (c1 && c5) {
           DESTROY_VALUE(*(array->d_firstElement +
            (i1 - low[0])*stride[0] +
            (i2 - low[1])*stride[1] +
            (i3 - low[2])*stride[2] +
            (i4 - low[3])*stride[3] +
            (i5 - low[4])*stride[4] +
            (i6 - low[5])*stride[5] +
            (i7 - low[6])*stride[6]));
          *(array->d_firstElement +
            (i1 - low[0])*stride[0] +
            (i2 - low[1])*stride[1] +
            (i3 - low[2])*stride[2] +
            (i4 - low[3])*stride[3] +
            (i5 - low[4])*stride[4] +
            (i6 - low[5])*stride[5] +
            (i7 - low[6])*stride[6])
             = COPY_VALUE(value);
        }
      }
    }
  }
}
"""),


    Method("""\
Set element indices of an n-dimensional array to value. indices is assumed
to have the right number of elements for the dimension of array.""",
           """void
sidl_%ARRAY_TYPE%__array_set(struct %ARRAY_STRUCT%* array,
     %ARRAY_SPAC%            const int32_t indices[],
     %ARRAY_SPAC%            %ARRAY_CONST_TYPE% value)""",
           """{
  if (array) {
    %ARRAY_FORMAL_TYPE% *result = array->d_firstElement;
    int32_t i = 0;
    HELPER_VARIABLE;
    while (i < array->d_metadata.d_dimen) {
      if ((indices[i] < array->d_metadata.d_lower[i]) ||
          (indices[i] > array->d_metadata.d_upper[i])) return;
      result += ((indices[i] - array->d_metadata.d_lower[i])*
       array->d_metadata.d_stride[i]);
      ++i;
    }
    DESTROY_VALUE(*result);
    *result = COPY_VALUE(value);
  }
}
"""),

    Method("""\
Return the dimension of array. If the array pointer is NULL,
zero is returned.""",
           """int32_t
sidl_%ARRAY_TYPE%__array_dimen(const struct %ARRAY_STRUCT%* array)""",
           """{
  return sidl__array_dimen((const struct sidl__array*)array);
}
"""),

    Method("""\
Return the lower index bound on dimension ind. If ind is not a valid
dimension, zero is returned. The valid range for ind is 0 to dimen-1.""",
           """int32_t
sidl_%ARRAY_TYPE%__array_lower(const struct %ARRAY_STRUCT%* array,
     %ARRAY_SPAC%              const int32_t ind)""",
           """{
  return sidl__array_lower((const struct sidl__array*)array, ind);
}
"""),

    Method("""\
Return the upper index bound on dimension ind. If ind is not a valid
dimension, negative one is returned. The valid range for ind is 0 to
dimen-1.""",
           """int32_t
sidl_%ARRAY_TYPE%__array_upper(const struct %ARRAY_STRUCT%* array,
     %ARRAY_SPAC%              const int32_t ind)""",
           """{
  return sidl__array_upper((const struct sidl__array*)array, ind);
}
"""),


    Method("""\
Return the number of element in dimension ind. If ind is not a valid
dimension, negative one is returned. The valid range for ind is 0 to
dimen-1.""",
           """int32_t
sidl_%ARRAY_TYPE%__array_length(const struct %ARRAY_STRUCT%* array,
     %ARRAY_SPAC%               const int32_t ind)""",
           """{
  return sidl__array_length((const struct sidl__array*)array, ind);
}
"""),


    Method("""\
Return the stride of dimension ind. If ind is not a valid
dimension, zero is returned. The valid range for ind is 0 to
dimen-1.""",
           """int32_t
sidl_%ARRAY_TYPE%__array_stride(const struct %ARRAY_STRUCT%* array,
     %ARRAY_SPAC%               const int32_t ind)""",
           """{
  return sidl__array_stride((const struct sidl__array*)array, ind);
}
"""),

    Method("""\
Return a true value iff the array is a contiguous column-major ordered
array.  A NULL array argument causes 0 to be returned.""",
           """sidl_bool
sidl_%ARRAY_TYPE%__array_isColumnOrder(const struct %ARRAY_STRUCT%* array)""",
           """{
  return sidl__array_isColumnOrder((const struct sidl__array*)array);
}
"""),

    Method("""\
Return a true value iff the array is a contiguous row-major ordered
array.  A NULL array argument causes 0 to be returned.""",
           """sidl_bool
sidl_%ARRAY_TYPE%__array_isRowOrder(const struct %ARRAY_STRUCT%* array)""",
           """{
  return sidl__array_isRowOrder((const struct sidl__array*)array);
}
"""),

    Method("""\
Copy the contents of one array (src) to a second array (dest). For
the copy to take place, both arrays must exist and be of the same
dimension. This method will not modify dest's size, index bounds,
or stride; only the array element values of dest may be changed by
this function. No part of src is ever changed by copy.

On exit, dest[i][j][k]... = src[i][j][k]... for all indices i,j,k...
that are in both arrays. If dest and src have no indices in common,
nothing is copied. For example, if src is a 1-d array with elements
0-5 and dest is a 1-d array with elements 2-3, this function will
make the following assignments:
  dest[2] = src[2],
  dest[3] = src[3].
The function copied the elements that both arrays have in common.
If dest had elements 4-10, this function will make the following
assignments:
  dest[4] = src[4],
  dest[5] = src[5].
""",
           """void
sidl_%ARRAY_TYPE%__array_copy(const struct %ARRAY_STRUCT%* src,
     %ARRAY_SPAC%                   struct %ARRAY_STRUCT%* dest)""",
           """{
  if (src && dest && (src != dest) &&
     (src->d_metadata.d_dimen == dest->d_metadata.d_dimen) &&
      src->d_metadata.d_dimen) {
    const int32_t dimen = src->d_metadata.d_dimen;
    int32_t * restrict overlap = (int32_t *)malloc(sizeof(int32_t)*(size_t)dimen*4);
    HELPER_VARIABLE;
    if (overlap) {
      register %ARRAY_FORMAL_TYPE% const * restrict srcFirst =
        src->d_firstElement;
      register %ARRAY_FORMAL_TYPE% * restrict destFirst =
        dest->d_firstElement;
      register int32_t i;
      int32_t * restrict current = overlap + dimen;
      int32_t * restrict src_stride = current + dimen;
      int32_t * restrict dst_stride = src_stride + dimen;
      int32_t lower, upper, fastMover = dimen - 1, moverRank = 0;
      for(i = 0; i < dimen; ++i){
        lower = MAX(src->d_metadata.d_lower[i],dest->d_metadata.d_lower[i]);
        upper = MIN(src->d_metadata.d_upper[i],dest->d_metadata.d_upper[i]);
        overlap[i] = 1 + upper - lower;
        if (overlap[i] <= 0) goto cleanup;
        srcFirst += (src->d_metadata.d_stride[i]*
           (lower - src->d_metadata.d_lower[i]));
        destFirst += (dest->d_metadata.d_stride[i]*
           (lower - dest->d_metadata.d_lower[i]));
        current[i] = 0;
        src_stride[i] = src->d_metadata.d_stride[i];
        dst_stride[i] = dest->d_metadata.d_stride[i];
        if (((src_stride[i] == 1) || (src_stride[i] == -1) ||
             (dst_stride[i] == 1) || (dst_stride[i] == -1)) &&
            (overlap[i] >= moverRank)) {
          moverRank = overlap[i];
          fastMover = i;
        }
      }
      if (fastMover != dimen - 1) { /* move stride 1 to inner loop */
        /* this *might* improve cache performance */
        swap_i32(&overlap[fastMover], &overlap[dimen-1]);
        swap_i32(&src_stride[fastMover], &src_stride[dimen-1]);
        swap_i32(&dst_stride[fastMover], &dst_stride[dimen-1]);
      }
      switch(dimen) {
      case 1: /* handle a common special case */
        {
          const int32_t bound = overlap[0];
          const int32_t dstride = dst_stride[0];
          const int32_t sstride = src_stride[0];
          for(i = 0; i < bound; ++i) {
            DESTROY_VALUE(*destFirst);
            *destFirst = COPY_VALUE(*srcFirst);
            destFirst += dstride;
            srcFirst += sstride;
          }
        }
        break;
      case 2: /* handle a common special case (2-d arrays) */
        {
          const int32_t bound0 = overlap[0];
          const int32_t bound1 = overlap[1];
          const int32_t dstride1 = dst_stride[1];
          const int32_t sstride1 = src_stride[1];
          const int32_t dstride0 = dst_stride[0] - bound1*dstride1;
          const int32_t sstride0 = src_stride[0] - bound1*sstride1;
          int32_t j;
          for(i = 0; i < bound0; ++i) {
            for(j = 0; j < bound1; ++j) {
              DESTROY_VALUE(*destFirst);
              *destFirst = COPY_VALUE(*srcFirst);
              destFirst += dstride1;
              srcFirst += sstride1;
            }
            destFirst += dstride0;
            srcFirst += sstride0;
          }
        }
        break;
      case 3: /* handle a common special case (3-d arrays) */
        {
          const int32_t bound0 = overlap[0];
          const int32_t bound1 = overlap[1];
          const int32_t bound2 = overlap[2];
          const int32_t dstride2 = dst_stride[2];
          const int32_t sstride2 = src_stride[2];
          const int32_t dstride1 = dst_stride[1] - bound2*dstride2;
          const int32_t sstride1 = src_stride[1] - bound2*sstride2;
          const int32_t dstride0 = dst_stride[0] - bound1*(dstride1 + bound2*dstride2);
          const int32_t sstride0 = src_stride[0] - bound1*(sstride1 + bound2*sstride2);
          
          int32_t j, k;
          for(i = 0; i < bound0; ++i) {
            for(j = 0; j < bound1; ++j) {
              for(k = 0; k < bound2; ++k) {
                DESTROY_VALUE(*destFirst);
                *destFirst = COPY_VALUE(*srcFirst);
                destFirst += dstride2;
                srcFirst += sstride2;
              }
              destFirst += dstride1;
              srcFirst += sstride1;
            }
            destFirst += dstride0;
            srcFirst += sstride0;
          }
        }
        break;
      default: /* handle the general case */
        do {
          DESTROY_VALUE(*destFirst);
          *destFirst = COPY_VALUE(*srcFirst);
          /* the whole point of this for-loop is to move forward one element */
          for(i = dimen - 1; i >= 0; --i) {
            ++(current[i]);
            if (current[i] >= overlap[i]) {
            /* this dimension has been enumerated already reset to beginning */
              current[i] = 0;
              /* prepare to next iteration of for-loop for i-1 */
              destFirst -= ((overlap[i]-1) * dst_stride[i]);
              srcFirst -= ((overlap[i]-1) * src_stride[i]);
            }
            else {
              /* move forward one element in dimension i */
              destFirst += dst_stride[i];
              srcFirst += src_stride[i];
              break; /* exit for loop */
            }
          }
        } while (i >= 0);
        break;
      }
cleanup:
      free(overlap);
    }
  }
}
"""),

    Method("""\
If necessary, convert a general matrix into a matrix with the required
properties. This checks the dimension and ordering of the matrix.
If both these match, it simply returns a new reference to the existing
matrix. If the dimension of the incoming array doesn't match, it
returns NULL. If the ordering of the incoming array doesn't match the
specification, a new array is created with the desired ordering and
the content of the incoming array is copied to the new array.

The ordering parameter should be one of the constants defined in
enum sidl_array_ordering (e.g. sidl_general_order,
sidl_column_major_order, or sidl_row_major_order). If you
specify sidl_general_order, this routine will only check the
dimension because any matrix is sidl_general_order.

The caller assumes ownership of the returned reference unless it's NULL.
""",
           """struct %ARRAY_STRUCT%*
sidl_%ARRAY_TYPE%__array_ensure(struct %ARRAY_STRUCT%* src,
     %ARRAY_SPAC%               int32_t                dimen,
     %ARRAY_SPAC%               int32_t                ordering)""",
           """{
  struct %ARRAY_STRUCT%* result = NULL;
  if (src && (src->d_metadata.d_dimen == dimen)) {
    switch(ordering) {
    case sidl_column_major_order:
      if (sidl_%ARRAY_TYPE%__array_isColumnOrder(src)) {
        sidl_%ARRAY_TYPE%__array_addRef(src);
        result = src;
      }
      else {
        result = sidl_%ARRAY_TYPE%__array_createCol
          (dimen, src->d_metadata.d_lower, src->d_metadata.d_upper);
        sidl_%ARRAY_TYPE%__array_copy(src, result);
      }
      break;
    case sidl_row_major_order:
      if (sidl_%ARRAY_TYPE%__array_isRowOrder(src)) {
        sidl_%ARRAY_TYPE%__array_addRef(src);
        result = src;
      }
      else {
        result = sidl_%ARRAY_TYPE%__array_createRow
          (dimen, src->d_metadata.d_lower, src->d_metadata.d_upper);
        sidl_%ARRAY_TYPE%__array_copy(src, result);
      }
      break;
    default:
      sidl_%ARRAY_TYPE%__array_addRef(src);
      result = src;
      break;
    }
  }
  return result;
}
"""),


    ]


DirectAccessMethods = [
    Method("""\
Return a pointer to the first element of the data space of the array.
Using the lower and stride information, you can access elements of the
array without using a function call. NULL is returned iff array is NULL.

Direct access should only be used when efficiency requires it.""",
           """%ARRAY_FORMAL_TYPE% *
sidl_%ARRAY_TYPE%__array_first(const struct %ARRAY_STRUCT%* array)""",
           """{
  return array ? array->d_firstElement : NULL;
}
""")
    ]


class DataType:
    def __init__(self, name, formal_type, const_type, zero,
                 public=1, initMsg=1, cond_const_type=None):
        self.name = name
        self.formal_type = formal_type
        self.cond_const_type = cond_const_type
        self.const_type = const_type
        self.public = public
        self.initMsg = initMsg
        self.zero = zero
        if (not self.cond_const_type):
            self.cond_const_type = self.const_type

DataTypes = [
    DataType("bool", "sidl_bool", "const sidl_bool", 0),
    DataType("int", "int32_t", "const int32_t", 0),
    DataType("long", "int64_t", "const int64_t", 0),
    DataType("float", "float", "const float", 0),
    DataType("double", "double", "const double", 0),
    DataType("fcomplex", "struct sidl_fcomplex",
             "const struct sidl_fcomplex",
             "{0, 0}"),
    DataType("dcomplex",
             "struct sidl_dcomplex",
             "const struct sidl_dcomplex",
             "{0, 0}"),
    DataType("char", "char", "const char", "'\\0'"),
    DataType("opaque", "void *", "void * const", "NULL"),
    DataType("string", "char *", "const char *", "NULL", 0, 2),
    DataType("interface", "sidl_BaseInterface",
             "sidl_BaseInterface const", "NULL", 0, 3,
             "sidl_BaseInterface")
    ]

def WriteHeader(keywords, type):
    header = open("sidl_" + type.name + "_IOR.h", "w")
    header.write(ReplaceKeywords(headerTop, keywords))
    if (type.public):
        methodList = Methods + DirectAccessMethods
        header.write(ReplaceKeywords(dataStructure, keywords))
    else:
        methodList = Methods
        header.write("/* forward declaration of opaque structure */\n")
        header.write("struct ")
        header.write(keywords['%ARRAY_STRUCT%'])
        header.write(";\n")
    if (type.initMsg == 3):
        header.write("""
#ifndef included_sidl_BaseInterface_h        
#include "sidl_BaseInterface.h"
#endif
""")
    header.write("""
#ifdef __cplusplus
extern "C" { /*}*/
#endif

""")
    for method in methodList:
        if (method.public):
            WriteComments(header,
                          ReplaceKeywords(method.comment,keywords),
                          method.initMsg & type.initMsg)
            header.write(ReplaceKeywords(method.signature,keywords))
            header.write(";\n\n")
    header.write(ReplaceKeywords(headerBottom, keywords))
    header.close()
    header = None
    
def WriteImpl(keywords, type):
    impl = open("sidl_" + type.name + "_IOR.c", "w")
    impl.write(ReplaceKeywords(implTop, keywords))
    if (type.initMsg == 3):
            impl.write("""
#define HELPER_VARIABLE struct sidl_BaseInterface__object *throwaway_exception
#define COPY_VALUE(x) ((x) ? (sidl_BaseInterface_addRef((x),&throwaway_exception), (x)) : (x))
#define DESTROY_VALUE(x) if (x) sidl_BaseInterface_deleteRef((x),&throwaway_exception)
#define INIT_VALUES(ptr,size) if (ptr) memset((ptr), 0, (size))
#define DESTROY_VALUES_TOO 1

""")
    else:
        if (type.initMsg == 2):
            impl.write("""
#include "sidl_String.h"
#define HELPER_VARIABLE
#define COPY_VALUE(x) sidl_String_strdup((x))
#define DESTROY_VALUE(x) sidl_String_free((x))
#define INIT_VALUES(ptr,size) if (ptr) memset((ptr), 0, (size))
#define DESTROY_VALUES_TOO 1

""")
        else:
            impl.write("""
#define HELPER_VARIABLE
#define COPY_VALUE(x) (x)
#define DESTROY_VALUE(x)
#define INIT_VALUES(ptr,size)

""")
    impl.write(ReplaceKeywords(
      "static %ARRAY_FORMAL_TYPE% const sidl_%ARRAY_TYPE%__array_zero = ",
      keywords));
    impl.write(str(type.zero));
    impl.write(";\n\n");
               
    if (not type.public):
        methodList = Methods
        impl.write(ReplaceKeywords(dataStructure, keywords))
    else:
        methodList = Methods + DirectAccessMethods
    for method in methodList:
        impl.write(ReplaceKeywords(method.signature,keywords))
        impl.write("\n")
        impl.write(ReplaceKeywords(method.impl, keywords))
        impl.write("\n")
    impl.write(ReplaceKeywords(implBottom, keywords))
    impl.close()
    impl = None
    

for type in DataTypes:
    keywords = {}
    keywords["%ARRAY_TYPE%"] = type.name
    keywords["%ARRAY_SPAC%"] = ' ' * len(type.name)
    keywords["%ARRAY_FORMAL_TYPE%"] = type.formal_type
    keywords["%ARRAY_COND_CONST_TYPE%"] = type.cond_const_type
    keywords["%ARRAY_CONST_TYPE%"] = type.const_type
    keywords["%ARRAY_STRUCT%"] = "sidl_" + type.name + "__array"
    WriteHeader(keywords, type)
    WriteImpl(keywords, type)

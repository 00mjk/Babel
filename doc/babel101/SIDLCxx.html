<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.78 [en] (X11; U; Linux 2.4.18-c0smp i686) [Netscape]">
   <title>SIDL C++ Crash Course</title>
<!-- 
  File: SIDLCxx.html
  Copyright: (c) 2001 Lawrence Livermore National Security, LLC
  Revision: $Revision: 6171 $
  Modified: $Date: 2007-10-08 16:39:28 -0700 (Mon, 08 Oct 2007) $
  Description: Basic documentation for SIDL C++
-->
</head>
<body>

<h1>
Crash Course in SIDL C++ Bindings</h1>

<h2>
Gary Kumfert &lt;kumfert@llnl.gov><br>
BABEL Version 0.8.x<br>
06 Sep 2001, updated 21 Jan 2003</h2>

<h3>
<a NAME="Introduction"></a>Introduction</h3>

<blockquote>The intent of this file is to provide the minimum information
necessary for people who are familiar with object-oriented/component oriented
software development and the SIDL (Scientific Interface Definition Language)
to implement classes in C++ or use classes implemented by someone else
from a C++ driver. If you are unfamiliar with SIDL, additional material
is available from <a href="http://www.llnl.gov/CASC/components/">http://www.llnl.gov/CASC/components/</a>.
<p>The assumption for this document is that you already have a SIDL file
for a software library, and you need to call it from C++ or implement it
in C++.</blockquote>

<h3>
<a NAME="Installation"></a>Installation</h3>

<blockquote>Unlike C or FORTRAN 77, there is no runtime library created
for a particular C++ compiler at installation. Instead, when you generate
C++ from SIDL, you will find Stubs (aka proxy classes) generated for SIDL
base classes and will have to compile and link them into your application.
<p>That said, if you switch to a different compiler after installation,
there may be some values set in babel_config.h that become invalid. This
can be overcome by copying the headerfile, making the necessary changes,
and placing the modified headerfile earlier in the include path than the
original one.</blockquote>

<h3>
<a NAME="C++ header suffix"></a>SIDL C++ Header Suffix</h3>

<blockquote>The first thing that C++ users will notice is that C++ headers
have a ".hh" suffix to distinguish them from C's ".h" suffix. This convention
was born out of necessity to distinguish both differing headerfiles and
their include guards.</blockquote>

<h3>
<a NAME="C++ header"></a>SIDL's Main C++ Header File</h3>

<blockquote>All C++ code generated by Babel #includes a file called "SIDL_cxx.hh".
This file includes babel_config.h, the C header file that defines configuration
information. SIDL_cxx.hh also puts things like std::string and std::complex
into the global namespace. Finally, SIDL_cxx.hh defines some C++ classes
in the SIDL namespace that
<ul>
<li>
<b>SIDL::StubBase</b> [implementation detail] Common base class for all
C++ stubs (proxy classes)</li>

<li>
<b>template&lt;T,U,V> SIDL::array_mixin</b> [implementation detail] Common
base class for all C++ array classes.</li>

<li>
<b>typedefs</b> for SIDL::fcomplex, SIDL::dcomplex, and SIDL::opaque (usually
std::complex<float>, std::complex<double> and void*, respectively)</li>

<li>
<b>template&lt;T> SIDL::array</b> Template array type for SIDL arrays.</li>

<li>
<b>template specializations</b> [implementation detail] specialization
of arrays of all SIDL types are defined in this file.</li>
</ul>
</blockquote>

<h3>
<a NAME="Types"></a>Basic Information about types</h3>

<blockquote>The basic types in SIDL are mapped into C++ according to the
following table:
<br>&nbsp;
<table BORDER CELLSPACING=2 CELLPADDING=2 >
<caption><tbody>
<br></tbody></caption>

<tr>
<th VALIGN=TOP>SIDL TYPE</th>

<th VALIGN=TOP>C++ TYPE</th>

<th VALIGN=TOP>NOTES</th>
</tr>

<tr>
<td VALIGN=TOP>int</td>

<td VALIGN=TOP>int32_t</td>
</tr>

<tr>
<td VALIGN=TOP>long</td>

<td VALIGN=TOP>int64_t</td>
</tr>

<tr>
<td VALIGN=TOP>float</td>

<td VALIGN=TOP>float</td>
</tr>

<tr>
<td VALIGN=TOP>double</td>

<td VALIGN=TOP>double</td>
</tr>

<tr>
<td VALIGN=TOP>bool</td>

<td VALIGN=TOP>bool</td>
</tr>

<tr>
<td VALIGN=TOP>char</td>

<td VALIGN=TOP>char</td>
</tr>

<tr>
<td VALIGN=TOP>string</td>

<td VALIGN=TOP>std::string</td>
</tr>

<tr>
<td VALIGN=TOP>fcomplex</td>

<td VALIGN=TOP>sidl::fcomplex</td>
</tr>

<tr>
<td VALIGN=TOP>dcomplex</td>

<td VALIGN=TOP>sidl::dcomplex</td>
</tr>

<tr>
<td VALIGN=TOP>enum</td>

<td VALIGN=TOP>enum</td>
</tr>

<tr>
<td VALIGN=TOP>opaque</td>

<td VALIGN=TOP>sidl::opaque</td>
</tr>

<tr>
<td VALIGN=TOP>interface</td>

<td VALIGN=TOP>class</td>
</tr>

<tr>
<td VALIGN=TOP>class</td>

<td VALIGN=TOP>class</td>
</tr>

<tr>
<td VALIGN=TOP>array</td>

<td VALIGN=TOP>sidl::array<T> (template specialization)</td>
</tr>
</table>
</blockquote>

<h3>
<a NAME="Calling"></a>Calling methods from C++</h3>

<blockquote>Since C++ is an object-oriented language, there is a lot less
programmer overhead in using SIDL from the C++ perspective than from non-OO
languages such as C or FORTRAN 77. Here's a table summarizing how SIDL
features are mapped to C++.
<table BORDER CELLSPACING=2 CELLPADDING=2 >
<caption><tbody>
<br></tbody></caption>

<tr>
<th VALIGN=TOP>SIDL Feature</th>

<th VALIGN=TOP>C++ Implementation</th>
</tr>

<tr>
<th>packages</th>

<td>C++ namespaces (no name transformations)</td>
</tr>

<tr>
<th>version numbers</th>

<td>ignored</td>
</tr>

<tr>
<th>interface</th>

<td>C++ class, (called "stub", serves as a proxy to the implementation)</td>
</tr>

<tr>
<th>class</th>

<td>C++ class, (called "stub", serves as a proxy to the implementation)</td>
</tr>

<tr>
<th>methods</th>

<td>C++ member functions, no name mangling
<br><b>NOTE:</b> member functions beginning with a leading underscore "_"
may be Babel internals, or specific to C++ binding.</td>
</tr>

<tr>
<th>static methods</th>

<td>static C++ member functions, no name mangling, even works for dynamically
loaded objects</td>
</tr>

<tr>
<th>exceptions</th>

<td>thrown and caught using C++ exception handling</td>
</tr>

<tr>
<th>reference counting</th>

<td>SIDL C++ stubs can be treated as smart-pointers.
<br>Constructors, destructors, and operators are overloaded so that explicit
calls to addRef() or deleteRef() are rarely needed.</td>
</tr>

<tr>
<th>casting</th>

<td>
<ul>
<li>
Assignment operators are overloaded to handle safe casting up and down
the inheritance heirarchy</li>

<li>
User should <b>never</b> call <tt>dynamic_cast&lt;>()</tt> on a SIDL object...
the stubs inheritance heirarchy does <b>not</b> follow the SIDL inheritance
heirarchy.&nbsp;</li>

<li>
Attempted downcasts using assignment should be checked by a call to (is_nil(),
or not_nil()).&nbsp;</li>
</ul>
</td>
</tr>

<tr>
<th>instance creation</th>

<td>Use static member function "_create". The default constructor for a
C++ stub creates the equivalent of a NULL pointer. Works only with non-abstract
classes.&nbsp;</td>
</tr>
</table>

<p>These proxy classes (we call "stubs") serve as the firewall between
the application in C++ and Babel's internal workings. As one would expect,
the proxy classes maintain minimal state so that (unlike C or F77) there
is no special context argument added to non-static member functions.
<p>Here are example using standard classes:
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SIDL::BaseClass object = SIDL::BaseClass::_create();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SIDL::BaseInterface interface = object;</pre>
Here is an example call to the addSearchPath in the SIDL.Loader class:
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::string s('/try/looking/here');
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SIDL::Loader::addSearchPath( s );</pre>
Here is another example adapted from the BABEL regression tests. Package
ExceptionTest has a class named Fib with a method declared in SIDL as follows:
<pre>&nbsp;&nbsp;&nbsp; int getFib(in int n, in int max_depth, in int max_value, in int depth)
&nbsp;&nbsp;&nbsp; throws NegativeValueException, FibException;</pre>
Here is the outline of a C++ code fragment to use this method.
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ExceptionTest::Fib fib = ExceptionTest::Fib::_create();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try {&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int result = fib.getFib( 4, 100, 32000, 0 );
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; "Result of fib.getFib() = " &lt;&lt; result &lt;&lt; endl;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } catch ( ExceptionTest::NegativeValueException&nbsp; e ) {&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } catch ( ExceptionTest::FibException e ) {&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</pre>
Here is how you should invoke BABEL to create the C++ stubs from a SIDL
file.
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; babel --client=C++ file.sidl</pre>
or simply
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; babel -cC++ file.sidl</pre>
This will create a <tt>babel.make</tt> file, some C headers and sources,
and many C++ headers and sources. Files ending in ".c" or ".h" are in C,
files ending in ".cc" or ".hh" are C++.
<p>You will need to compile and link the files together to use the C++
stubs.</blockquote>

<h3>
<a NAME="Implementing"></a>Implementing SIDL Classes in C++</h3>

<blockquote>Much of the information from the previous section is pertinent
to implementing a SIDL class in C++. The types of the arguments are as
indicated in the
<a href="#Types">type table</a>. Your implementation can
call other SIDL methods, in which case follow the rules for client calls.
<p>To create the implementation, you must first have a valid SIDL file,
then invoke Babel as follows:
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; babel --server=C++ file.sidl</pre>
or use the shorter arguments
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; babel -sC++ file.sidl</pre>
This will create a makefile fragment called <tt>babel.make</tt>, several
C headers and source files, and numerous C++ header and source files. To
create a working implementation, the only files that need to be hand-edited
are the C++ "Impl" files (header and source files that end in <tt>_Impl.hh</tt>
or <tt>_Impl.cc</tt>). All your additions to this file should be made between
code splicer pairs. Code splicing is a technique Babel uses to preserve
hand-edited code between multiple invoactions of Babel. This allows a developer
to refine their SIDL file without ruining all their previous implementations.
Code between splicer pairs will be retained by subsequent invocations of
BABEL; code outside splicer pairs is not.
<p>Here is an example of a code splicer pair in C++. In this example, you
would replace the line "<tt>// Insert code here...</tt> " with your implementation.
<pre>void MyPackage::MyClass::myMethod() {
&nbsp; // DO-NOT-DELETE splicer.begin(MyPackage.MyClass.myMethod)
&nbsp; // Insert code here...
&nbsp; // DO-NOT-DELETE splicer.end(MyPackage.MyClass.myMethod)
}</pre>
It is important to understand where and why splicer blocks occur. Splicer
blocks appear at the beginning and end of each Impl header and source file;
for developers to add #includes and other miscellaneous items respectively.
In the headers, there is a splicer block inside the class definition for
developers to add any data members to the class that they wish. There is
<b>not</b>
currently a splicer block that allows a user to make the impl class inherit
from some other class. This may change in the future, but current schools
of thought hold that best practice is to use delegation instead of inheritance
if developers want to hook SIDL generated impl classes to some existing
C++ class library. In the source files, splicer blocks appear in each method
implementation. There are two implicit methods (i.e. methods that did not
appear in the SIDL file) that must also be implemented. The <tt>_ctor</tt>
method is a constructor function that is run whenever an object is created.
The
<tt>_dtor</tt> method is a destructor function that is run whenever
an object is destroyed. If the object has no state, these functions are
typically empty.</blockquote>

<h3>
<a NAME="Arrays"></a>Accessing SIDL Arrays from C++</h3>

<blockquote>Although it would be feasible to expose the underlying C array
API to create, destroy and access array elements and meta-data, the C++
bindings provide a sidl::array&lt;T> template mechanism that is more in
keeping with C++ idioms.
<p>For SIDL built-in types, template specializations of sidl::array&lt;T>
are defined in <tt>SIDL_cxx.hh</tt>. For SIDL interface and classes, the
array template is again specialized in the corresponding stub header. The
reason for the extensive use of template specialization is an effort to
hide the detail that the array implementation is really templated on three
terms: the type of the C struct that represents the array internally, the
internal representation of each item in the array, and the C++ representation
of each item in the array. (See <tt>array_mixin</tt> in <tt>SIDL_cxx.hh</tt>
for grungy implementation details.)
<p>An example is given below.
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int32_t len = 10; // array length=10
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int32_t dim = 1;&nbsp; // one dimensional
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int32_t lower[1] = {0}; // zero offset
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int32_t upper[1] = {len-1};
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int32_t prime = nextPrime(0);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // create a SIDL array of primes.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SIDL::array&lt;int> a;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a.create(dim,lower,upper);&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( int i=0; i&lt;len; ++i ) {&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prime = nextPrime( prime );
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a.set(v,i);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</pre>
Of course, the example above is only one way to create an array. The list
of member functions for all C++ array classes is:
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // constructors
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; array ( array_ior_t * src ); // internal
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; array () ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // empty

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // destructor
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~array() ;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // creation&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool create( int32_t dimen, const int32_t lower[],&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const int32_t upper[]);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool borrow( item_ior_t * first_element, int32_t dimen,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const int32_t lower[], const int32_t upper[],&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const int32_t stride[]);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void destroy();

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // get/set
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; item_cxx_wrapper_t get(int32_t i, int32_t j=0,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int32_t k=0, int32_t l=0);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void set(item_cxx_wrapper_t element, int32_t i, int32_t j=0,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int32_t k=0, int32_t l=0);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // other accessors
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int32_t dim() const;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int32_t lower( int32_t dim ) const;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int32_t upper( int32_t dim ) const;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool is_nil() const;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool not_nil() const;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // get a const pointer to the actual array ior&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const array_ior_t* _get_ior() const { return d_array; }

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // get a non-const pointer to the actual array ior
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; array_ior_t* _get_ior() { return d_array;}</pre>
where
<ul>
<li>
<tt>array_ior_t</tt> is the type of the C struct that represents the array
internally,</li>

<li>
<tt>item_ior_t</tt> is the internal representation of each item in the
array,</li>

<li>
<tt>item_cxx_wrapper_t</tt> is the C++ representation of each item in the
array</li>
</ul>
</blockquote>

</body>
</html>

#! /bin/sh

## This subroutine prints standard usage message
#
usage()
{
    exit_code=$1
    cat <<EOF
Usage: $0 /absolute/path/to/babel-config> | --help

This little script generates a few small files to complete
the build system for Babel-Wave.  These files include
    settings.make -- Makefile fragment
    babelenv.py   -- Python module to initialize environment
    wave2d.scl    -- SIDL Class Loader File

The absolute path to the babel-config script is the only requirement.
EOF
    exit $exit_code
}

#
# This subroutine check commandline options
#
check_opts()
{
    # if wrong number of arguments, it is an error
    if test $# -eq 0; then
        usage 1
    fi
    
    if test $1 = "-v"; then
        verbose=1
        shift
    fi
    
    if test $# -ne 1; then
        usage 1
    fi
    
    # allow various types of help flags (not an error)
    if test \( "$1" = "--help" \) -o \( "$1" = "-help" \) -o \( "$1" = "-h" \) ; then
        usage 0
    fi
    
    # make sure the argument is an executable
    if test -f  "$1"; then
        bc="$1"
    else
        echo "$0: error: '$1' is not an executable file" >&2
        exit 1
    fi 
    
    result=`$bc --query-var=PACKAGE 2>/dev/null`
    if test "$result" != "babel" ; then
        echo "$0: error: '$1' does not act like a valid babel-config file" >&2
        echo "           ('--query-var=PACKAGE' does not return 'babel')" >&2
        exit 1
    fi
    echo $bc
}

#
# Used to 
#
config_var()
{
    varname=$1
    shift
    value="$@"
    if test $verbose -ne 0; then
	echo $varname = $value
    fi
    echo $varname="$value" >> $outfile
}

#
# This generates a big settings.make file and is 
# not so useful with the newer babel-cc scripts
#
generate_settings() { 
bc=$1
outfile=$2
cat <<EOF > $outfile
# Generated by mini-configure

#
# All other settings are determined based where this
# babel-config script is
#

EOF
config_var BABEL_CONFIG "$bc"

cat <<EOF > $outfile

###############################################################3
# 
# There should be no reason to edit anything below this line.
# Only settings from an installed Babel distro are carried over
# in this file.
#
EOF
TOPDIR=`pwd`
config_var TOPDIR "$TOPDIR"
echo >> $outfile

config_var BABEL_VERSION `$bc --version`
config_var BABEL_PREFIX `$bc --prefix`
config_var BABEL_EPREFIX `$bc --exec-prefix`
config_var BABEL_INCLDIR `$bc --includedir`
config_var BABEL_BINDIR `$bc --bindir`
config_var BABEL_LIBDIR `$bc --libdir`
config_var BABEL `$bc --bindir`/babel
config_var BABEL_LIBTOOL `$bc --bindir`/babel-libtool

cat <<EOF >> $outfile

# These are the kinds of things that are determined
# at configure time.  Again, babel-config is helpful, 
# but it is not the final word.  Babel uses libtool
# which does some argument processing of its own.
# Therefore these args are pushed into babel-libool.
EOF

config_var CPP gcc -E --traditional-cpp -P -x c
config_var INCLUDES `$bc --includes`
SHARED_LIB_VAR=`$bc --query-var=SHARED_LIB_VAR`
config_var SHARED_LIB_VAR  $SHARED_LIB_VAR
echo >> $outfile

config_var CC `$bc --query-var=CC`
config_var CFLAGS `$bc --flags-c`
config_var CLIBS `$bc --libs-c`
echo >> $outfile

config_var CXX `$bc --query-var=CXX`
config_var CXXFLAGS `$bc --flags-c++`
config_var CXXLIBS `$bc --libs-c++`
echo >> $outfile

config_var FC `$bc --query-var=FC`
config_var FCFLAGS `$bc --flags-f90`
config_var FCLIBS `$bc --libs-f90`
echo >> $outfile

config_var PYTHON `$bc --which-var=PYTHON`
PYTHONINC=`$bc --query-var=PYTHONINC`
config_var PYTHONINC $PYTHONINC
PYTHON_SUBDIR=`$bc --query-var=PYTHONLIB`
PYTHON_SUBDIR=`basename $PYTHON_SUBDIR`
config_var PYTHON_SUBDIR $PYTHON_SUBDIR
BABEL_INCLDIR=`$bc --includedir`
BABEL_LIBDIR=`$bc --libdir`
config_var BABEL_PYEXTENSION_INCLDIR ${BABEL_INCLDIR}/${PYTHON_SUBDIR}/babel
config_var BABEL_PYEXTENSION_LIBDIR ${BABEL_LIBDIR}/${PYTHON_SUBDIR}/site-packages
echo >> $outfile

cat <<EOF >> $outfile
# suffix rules
.SUFFIXES:
.SUFFIXES: .cc .c .F90 .lo .o

.cc.lo:
	\$(BABEL_LIBTOOL) --mode=compile \$(CXX) -c -o \$@ \$(CPPFLAGS) \$(CXXFLAGS) \$(INCLUDES) \$< 

.c.lo:
	\$(BABEL_LIBTOOL) --mode=compile \$(CC) -c -o \$@ \$(CPPFLAGS) \$(CFLAGS) \$(INCLUDES) \$< 

.c.o:
	\$(CC) -c -o \$@ \$(CPPFLAGS) \$(CFLAGS) \$(INCLUDES) \$< 

.F90.o: 
	\$(CPP) \$< \$(INCLUDES) -o \$(@:.o=.f90) \$<
	\$(F90) \$(F90FLAGS) \$(INCLUDES) -c -o \$@ \$(@:.o=.f90)
	rm -f \$(@:.o=.f90)

EOF
}

generate_babelenv() { 
outfile=$1
libdir=`$bc --libdir`
pyversion=`$bc --query-var=PYTHON_VERSION`

cat <<EOF >$outfile
#! /bin/env python

#
# Sets up environment variables for Python to find Babel and wave
#
import os
import sys

SHARED_LIB_VAR="$SHARED_LIB_VAR"
# enable this line for debuggin
# os.environ['SIDL_DEBUG_DLOPEN'] = '1'
os.environ['SIDL_DLL_PATH']="${libdir};.."
if os.environ[SHARED_LIB_VAR]:
    os.environ[SHARED_LIB_VAR]= os.environ[SHARED_LIB_VAR] + ":$libdir"
else:
    os.environ[SHARED_LIB_VAR] = "$libdir"
sys.path = sys.path + [ "${libdir}/python${pyversion}/site-packages" ]

EOF
}

generate_scl() { 
outfile=$1
p=`pwd`
cat <<EOF >$outfile
<?xml version="1.0" ?>
<scl>
  <library uri="${p}/libCxx/libwave2d.cxx.la" scope="global" resolution="now">
    <class name="cxx.WavePropagator" desc="ior/impl"/>
    <class name="cxx.ScalarField" desc="ior/impl"/>
    <class name="cxx.ShapeFactory" desc="ior/impl"/>
  </library>
  <library uri="${p}/libF90/libwave2d.f90.la" scope="global" resolution="now">
    <class name="f90.WavePropagator" desc="ior/impl"/>
    <class name="f90.ScalarField" desc="ior/impl"/>
  </library>
</scl>
EOF
}

#
#
#
outfile=settings.make
verbose=0
bc=`check_opts $@`
if test \( "x$bc" != x \) -a \( -x "$bc" \);  then   
    generate_settings "$bc" "$outfile"
    generate_babelenv runPython/babelenv.py
    generate_scl "wave2d.scl"
else
  usage 1
fi 
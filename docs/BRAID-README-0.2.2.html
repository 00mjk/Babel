<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<title>README<2></title>

</head>

<body>

<h1>BRAID 0.2.2 README                             <!-- -*- markdown -*- --></h1>

<p><strong>* Released 26 AUGUST 2011 *</strong></p>

<h2>About</h2>

<p>BRAID, the Braid system for Rewriting Abstract Descriptions, is a
compiler-like tool to generate the glue code necessary for language
interoperability. Developed by the
<a href="https://computation.llnl.gov/casc/components/">Components project</a> at
Lawrence Livermore National Laboratory, BRAID supports the Scientific
Interface Definition Language (SIDL) for the language-independent
declaration of interfaces associated with scientific software
packages.</p>

<h3>Relation to Babel</h3>

<p>The language bindings generated by BRAID are binary-compatible to
those generated by the related
<a href="https://computation.llnl.gov/casc/components/">Babel</a> tool. While
Babel handles traditional programming languages (such as C, C++,
Fortran (77-2008), Python, and Java), BRAID adds support for modern
<a href="http://en.wikipedia.org/wiki/Partitioned_global_address_space">PGAS</a>
languages.</p>

<p>In practice, this means that if you want to, for example, let a Chapel
program use a component implemented in Fortran 95, you would invoke
Babel for the Fortran code and Braid for Chapel code:</p>

<pre><code>braid --makefile --client=Chapel interface.sidl
babel --makefile --server=F95    interface.sidl
</code></pre>

<h2>Supported Languages</h2>

<p>At this moment Chapel client code is well-tested and considered
stable. Chapel server support exists, but will be redesigned after the
next release of the Chapel compiler, which will have support for
building Chapel libraries.</p>

<pre><code>Language | Client   Server
---------+----------------------
Chapel   | stable   experimental
UPC      | planned  planned
X10      | planned  planned
</code></pre>

<h3>Notes:</h3>

<p>In addition to all regular Babel/SIDL features, the Chapel backend
also extends the Chapel runtime to support <em>borrowed arrays</em>;
i.e. Arrays that are initialized by an external function and can be
passed to Chapel code without copying. It also provides an interface
for <em>distributed arrays</em> which allow non-Chapel code to access
non-local data residing in the PGAS-space.</p>

<p>The following features are not yet implemented: </p>

<p>Generic arrays, arrays of objects, structs, contracts, hooks and RMI.</p>

<h2>Installation</h2>

<p>BRAID uses an autotools-based build system, so the regular </p>

<pre><code>./configure &amp;&amp; make install
</code></pre>

<p>will work just fine. Below is the step-by-step break-down of the the
installation process:</p>

<pre><code>tar xvf braid-0.2.2.tar.bz2 &amp;&amp; cd braid-0.2.2
mkdir build &amp;&amp; cd build
../configure --prefix=&lt;INSTALL_PATH&gt;
make [-j&lt;N&gt;] &amp;&amp; make install

# other useful commands
../configure --help
make check
</code></pre>

<h3>Patching the Chapel compiler</h3>

<p>You will need to patch your Chapel 1.3.0 compiler using the following
command <em>after</em> running ./configure:</p>

<pre><code>bash &lt;builddir&gt;/patch-chapel-compiler.sh
</code></pre>

<p>The script will patch and recompile the compiler automatically. You
can undo this operation by running</p>

<pre><code>bash &lt;builddir&gt;/patch-chapel-compiler.sh --undo
</code></pre>

<p>this will reverse the effects of the patch.</p>

<h3>User-visible dependencies</h3>

<p>If you just want to compile and install BRAID, you will need:
- Python:        Version 2.6 or higher
- gcc, ld, Perl, AWK, sed</p>

<p>If you want to run the regression tests, you will also need:
- Babel:         Version 2.0 or higher
- Chapel:        Version 1.3.0
- Java:          JVM 1.6 or higher
- NumPy:         Version 1.0.4 or higher</p>

<h3>Developer-only dependencies</h3>

<ul>
<li>Make:          GNU make version 3.74 or higher</li>
<li>Autotools:     Version 2.65 or later</li>
<li>SWI-Prolog:    Version 5.10.4 or higher 
             (only needed if you intend to modify [ir,sidl].def)</li>
<li>Doxygen:       Version 1.6 or higher 
             (disable with ./configure --disable-documentation)</li>
<li>GNU flex</li>
</ul>

<h2>Development status                                </h2>

<p>BRAID is written in 98% Python; the SIDL scanner is implemented in
flex (C). Some of the Python sources are automatically generated from
a high-level specification (sidl.def, ir.def) by a Prolog script. The
implementation language choice is motivated by Python being the
highest-level language that we can assume to be pre-installed on all
our target systems. So far we have three components:</p>

<ul>
<li><p>A complete parser for SIDL which generates an object-oriented
intermediate representation (IR)</p></li>
<li><p>A converter to an extensible s-expression-based language
independent IR</p></li>
<li><p>Code generators that convert this IR into Chapel and C code. 
Other languages supported by Babel will follow.</p>

<p>To facilitate the writing of these code generators we put some
effort into extending Python with a pattern-matching mechanism
for arbitrarily complex tuples. (And the s-expressions from the
IR are internally represented as Python tuples.)</p></li>
</ul>

<p>This diagram shows the work-flow implemented in BRAID:</p>

<pre><code>             Parser               Conversion
+-------------+  +------------------+  +---------------------+
| SIDL        |--| SIDL-based       |--| Language indep. IR  |
|             |  | declarative IR   |  | (s-expressions)     |
+-------------+  +------------------+  +---------------------+
                                         |       |
                                         |       | Code
                                         |       | Generators
                                         |       |
                                       +-----------+ +----------+
                                       | Chapel    | | C, ...   |
                                       |           | |          |
                                       +-----------+ +----------+
</code></pre>

<p>The idea to use the s-expression-based IR to interface with ROTE
at some later point. Other components (e.g. PAUL) can also
generate this IR to get access to the code generators.</p>

<h2>Further Information</h2>

<p>The following files are available at the top of the
release directory structure provide additional information
on the Babel release:</p>

<ul>
<li>BUGS:       Lists known bugs</li>
<li>COPYRIGHT:  Lawrence Livermore National Security, LLC notice</li>
<li>INSTALL:    Provides installation instructions</li>
<li><p>README:     This file</p>

<p>Additional background information can be found at our web site at</p>

<p>http://www.llnl.gov/CASC/components/</p>

<p>and</p>

<p>http://compose-hpc.sourceforge.net/</p></li>
</ul>



	<script type="text/javascript" src="../../../project/js/piwik.js"></script>
	<script type="text/javascript">
		try {
			var piwikTracker = Piwik.getTracker("https://analytics.llnl.gov/piwik.php", 148);
			piwikTracker.trackPageView();
			piwikTracker.enableLinkTracking();
		} catch(err) {}
	</script>
	<noscript><p><img src="https://analytics.llnl.gov/piwik.php?idsite=148" style="border:0" alt="" /></p></noscript>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-40890147-1', 'auto');
  ga('send', 'pageview');

</script>
</body>
</html>
